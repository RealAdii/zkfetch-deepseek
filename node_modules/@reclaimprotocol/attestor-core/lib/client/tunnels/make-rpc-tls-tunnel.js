"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRpcTlsTunnel = void 0;
const tls_1 = require("@reclaimprotocol/tls");
const make_rpc_tcp_tunnel_1 = require("../../client/tunnels/make-rpc-tcp-tunnel");
const config_1 = require("../../config");
const utils_1 = require("../../utils");
/**
 * Makes a TLS tunnel that connects to the server via RPC protocol
 */
const makeRpcTlsTunnel = async ({ onMessage, onClose, tlsOpts, request, connect, logger }) => {
    const transcript = [];
    const tunnelId = request.id || (0, utils_1.generateTunnelId)();
    let tunnel;
    let client;
    let handshakeResolve;
    let handshakeReject;
    const waitForHandshake = new Promise((resolve, reject) => {
        handshakeResolve = resolve;
        handshakeReject = reject;
    });
    const tls = (0, tls_1.makeTLSClient)({
        host: request.host,
        ...tlsOpts,
        logger,
        onHandshake() {
            handshakeResolve === null || handshakeResolve === void 0 ? void 0 : handshakeResolve();
        },
        onApplicationData(plaintext) {
            return onMessage === null || onMessage === void 0 ? void 0 : onMessage(plaintext);
        },
        onTlsEnd: onConnectionClose,
        async write(packet, ctx) {
            const message = (0, tls_1.concatenateUint8Arrays)([
                packet.header,
                packet.content
            ]);
            transcript.push({
                sender: 'client',
                message: { ...ctx, data: message }
            });
            if (!tunnel) {
                // sends the packet as the initial message
                // to the plaintext tunnel. Prevents another
                // round trip to the server as we send the packet
                // in the same message as the tunnel creation.
                const createTunnelReqId = (0, utils_1.generateRpcMessageId)();
                client = connect([
                    {
                        id: createTunnelReqId,
                        createTunnelRequest: {
                            host: request.host || '',
                            port: request.port || config_1.DEFAULT_HTTPS_PORT,
                            geoLocation: request.geoLocation || '',
                            id: tunnelId
                        },
                    },
                    { tunnelMessage: { tunnelId, message } }
                ]);
                try {
                    await makeTunnel();
                    // wait for tunnel to be successfully created
                    await client.waitForResponse(createTunnelReqId);
                }
                catch (err) {
                    onConnectionClose(err);
                }
                return;
            }
            return tunnel.write(message);
        },
        onRead(packet, ctx) {
            transcript.push({
                sender: 'server',
                message: {
                    ...ctx,
                    data: (0, tls_1.concatenateUint8Arrays)([
                        packet.header,
                        // the TLS package sends us the decrypted
                        // content, so we need to get the orginal
                        // ciphertext received from the server
                        // as that's part of the true transcript.
                        ctx.type === 'ciphertext'
                            ? ctx.ciphertext
                            : packet.content
                    ])
                }
            });
        },
    });
    await tls.startHandshake();
    // wait for handshake completion
    await waitForHandshake;
    handshakeResolve = handshakeReject = undefined;
    return {
        transcript,
        tls,
        write(data) {
            return tls.write(data);
        },
        async close(err) {
            onConnectionClose(err);
            try {
                await tunnel.close(err);
            }
            catch (err) {
                logger === null || logger === void 0 ? void 0 : logger.error({ err }, 'err in close tunnel');
            }
        },
    };
    function onConnectionClose(err) {
        onClose === null || onClose === void 0 ? void 0 : onClose(err);
        // once the TLS connection is closed, we no longer
        // want to send `onClose` events back to the caller
        // of this function.
        onClose = undefined;
        handshakeReject === null || handshakeReject === void 0 ? void 0 : handshakeReject(err);
    }
    async function makeTunnel() {
        tunnel = await (0, make_rpc_tcp_tunnel_1.makeRpcTcpTunnel)({
            tunnelId,
            client: client,
            onMessage(data) {
                tls.handleReceivedBytes(data);
            },
            onClose(err) {
                tls.end(err);
            },
        });
        logger === null || logger === void 0 ? void 0 : logger.debug('plaintext tunnel created');
        return tunnel;
    }
};
exports.makeRpcTlsTunnel = makeRpcTlsTunnel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFrZS1ycGMtdGxzLXR1bm5lbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jbGllbnQvdHVubmVscy9tYWtlLXJwYy10bHMtdHVubmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQUFrRztBQUNsRyxnRkFBeUU7QUFDekUsdUNBQStDO0FBRy9DLHFDQUFrRTtBQXFCbEU7O0dBRUc7QUFDSSxNQUFNLGdCQUFnQixHQUF1RCxLQUFLLEVBQUMsRUFDekYsU0FBUyxFQUFFLE9BQU8sRUFDbEIsT0FBTyxFQUFFLE9BQU8sRUFDaEIsT0FBTyxFQUFFLE1BQU0sRUFDZixFQUFFLEVBQUU7SUFDSixNQUFNLFVBQVUsR0FBc0MsRUFBRSxDQUFBO0lBQ3hELE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxFQUFFLElBQUksSUFBQSx3QkFBZ0IsR0FBRSxDQUFBO0lBQ2pELElBQUksTUFBa0IsQ0FBQTtJQUN0QixJQUFJLE1BQW1DLENBQUE7SUFFdkMsSUFBSSxnQkFBcUQsQ0FBQTtJQUN6RCxJQUFJLGVBQW9ELENBQUE7SUFDeEQsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLE9BQU8sQ0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUM5RCxnQkFBZ0IsR0FBRyxPQUFPLENBQUE7UUFDMUIsZUFBZSxHQUFHLE1BQU0sQ0FBQTtJQUN6QixDQUFDLENBQUMsQ0FBQTtJQUVGLE1BQU0sR0FBRyxHQUFHLElBQUEsbUJBQWEsRUFBQztRQUN6QixJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUs7UUFDbkIsR0FBRyxPQUFPO1FBQ1YsTUFBTTtRQUNOLFdBQVc7WUFDVixnQkFBZ0IsYUFBaEIsZ0JBQWdCLHVCQUFoQixnQkFBZ0IsRUFBSSxDQUFBO1FBQ3JCLENBQUM7UUFDRCxpQkFBaUIsQ0FBQyxTQUFTO1lBQzFCLE9BQU8sU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFHLFNBQVMsQ0FBQyxDQUFBO1FBQzlCLENBQUM7UUFDRCxRQUFRLEVBQUUsaUJBQWlCO1FBQzNCLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEdBQUc7WUFDdEIsTUFBTSxPQUFPLEdBQUcsSUFBQSw0QkFBc0IsRUFBQztnQkFDdEMsTUFBTSxDQUFDLE1BQU07Z0JBQ2IsTUFBTSxDQUFDLE9BQU87YUFDZCxDQUFDLENBQUE7WUFDRixVQUFVLENBQUMsSUFBSSxDQUFDO2dCQUNmLE1BQU0sRUFBRSxRQUFRO2dCQUNoQixPQUFPLEVBQUUsRUFBRSxHQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFO2FBQ2xDLENBQUMsQ0FBQTtZQUVGLElBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDWiwwQ0FBMEM7Z0JBQzFDLDRDQUE0QztnQkFDNUMsaURBQWlEO2dCQUNqRCw4Q0FBOEM7Z0JBQzlDLE1BQU0saUJBQWlCLEdBQUcsSUFBQSw0QkFBb0IsR0FBRSxDQUFBO2dCQUNoRCxNQUFNLEdBQUcsT0FBTyxDQUFDO29CQUNoQjt3QkFDQyxFQUFFLEVBQUUsaUJBQWlCO3dCQUNyQixtQkFBbUIsRUFBRTs0QkFDcEIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLElBQUksRUFBRTs0QkFDeEIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLElBQUksMkJBQWtCOzRCQUN4QyxXQUFXLEVBQUUsT0FBTyxDQUFDLFdBQVcsSUFBSSxFQUFFOzRCQUN0QyxFQUFFLEVBQUUsUUFBUTt5QkFDWjtxQkFDRDtvQkFDRCxFQUFFLGFBQWEsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsRUFBRTtpQkFDeEMsQ0FBQyxDQUFBO2dCQUNGLElBQUksQ0FBQztvQkFDSixNQUFNLFVBQVUsRUFBRSxDQUFBO29CQUNsQiw2Q0FBNkM7b0JBQzdDLE1BQU0sTUFBTSxDQUFDLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO2dCQUNoRCxDQUFDO2dCQUFDLE9BQU0sR0FBRyxFQUFFLENBQUM7b0JBQ2IsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUE7Z0JBQ3ZCLENBQUM7Z0JBRUQsT0FBTTtZQUNQLENBQUM7WUFFRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDN0IsQ0FBQztRQUNELE1BQU0sQ0FBQyxNQUFNLEVBQUUsR0FBRztZQUNqQixVQUFVLENBQUMsSUFBSSxDQUFDO2dCQUNmLE1BQU0sRUFBRSxRQUFRO2dCQUNoQixPQUFPLEVBQUU7b0JBQ1IsR0FBRyxHQUFHO29CQUNOLElBQUksRUFBRSxJQUFBLDRCQUFzQixFQUFDO3dCQUM1QixNQUFNLENBQUMsTUFBTTt3QkFDYix5Q0FBeUM7d0JBQ3pDLHlDQUF5Qzt3QkFDekMsc0NBQXNDO3dCQUN0Qyx5Q0FBeUM7d0JBQ3pDLEdBQUcsQ0FBQyxJQUFJLEtBQUssWUFBWTs0QkFDeEIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVOzRCQUNoQixDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU87cUJBQ2pCLENBQUM7aUJBQ0Y7YUFDRCxDQUFDLENBQUE7UUFDSCxDQUFDO0tBQ0QsQ0FBQyxDQUFBO0lBRUYsTUFBTSxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUE7SUFDMUIsZ0NBQWdDO0lBQ2hDLE1BQU0sZ0JBQWdCLENBQUE7SUFFdEIsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLFNBQVMsQ0FBQTtJQUU5QyxPQUFPO1FBQ04sVUFBVTtRQUNWLEdBQUc7UUFDSCxLQUFLLENBQUMsSUFBSTtZQUNULE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQTtRQUN2QixDQUFDO1FBQ0QsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHO1lBQ2QsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUE7WUFDdEIsSUFBSSxDQUFDO2dCQUNKLE1BQU0sTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQTtZQUN4QixDQUFDO1lBQUMsT0FBTSxHQUFHLEVBQUUsQ0FBQztnQkFDYixNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsS0FBSyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUscUJBQXFCLENBQUMsQ0FBQTtZQUM5QyxDQUFDO1FBQ0YsQ0FBQztLQUNELENBQUE7SUFFRCxTQUFTLGlCQUFpQixDQUFDLEdBQXNCO1FBQ2hELE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRyxHQUFHLENBQUMsQ0FBQTtRQUNkLGtEQUFrRDtRQUNsRCxtREFBbUQ7UUFDbkQsb0JBQW9CO1FBQ3BCLE9BQU8sR0FBRyxTQUFTLENBQUE7UUFDbkIsZUFBZSxhQUFmLGVBQWUsdUJBQWYsZUFBZSxDQUFHLEdBQUcsQ0FBQyxDQUFBO0lBQ3ZCLENBQUM7SUFFRCxLQUFLLFVBQVUsVUFBVTtRQUN4QixNQUFNLEdBQUcsTUFBTSxJQUFBLHNDQUFnQixFQUFDO1lBQy9CLFFBQVE7WUFDUixNQUFNLEVBQUUsTUFBTztZQUNmLFNBQVMsQ0FBQyxJQUFJO2dCQUNiLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUM5QixDQUFDO1lBQ0QsT0FBTyxDQUFDLEdBQUc7Z0JBQ1YsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtZQUNiLENBQUM7U0FDRCxDQUFDLENBQUE7UUFFRixNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUE7UUFFekMsT0FBTyxNQUFNLENBQUE7SUFDZCxDQUFDO0FBQ0YsQ0FBQyxDQUFBO0FBeElZLFFBQUEsZ0JBQWdCLG9CQXdJNUIifQ==