"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeZkProofGenerator = makeZkProofGenerator;
exports.verifyZkPacket = verifyZkPacket;
exports.makeDefaultZkOperator = makeDefaultZkOperator;
exports.makeDefaultOPRFOperator = makeDefaultOPRFOperator;
exports.getEngineString = getEngineString;
exports.getEngineProto = getEngineProto;
const tls_1 = require("@reclaimprotocol/tls");
const zk_symmetric_crypto_1 = require("@reclaimprotocol/zk-symmetric-crypto");
const config_1 = require("../config");
const api_1 = require("../proto/api");
const env_1 = require("../utils/env");
const error_1 = require("../utils/error");
const generics_1 = require("../utils/generics");
const logger_1 = require("../utils/logger");
const redactions_1 = require("../utils/redactions");
const ZK_CONCURRENCY = +((0, env_1.getEnvVariable)('ZK_CONCURRENCY')
    || config_1.DEFAULT_ZK_CONCURRENCY);
async function makeZkProofGenerator({ zkOperators, oprfOperators, logger = logger_1.logger, zkProofConcurrency = ZK_CONCURRENCY, maxZkChunks = config_1.MAX_ZK_CHUNKS, cipherSuite, zkEngine = 'snarkjs' }) {
    const { default: PQueue } = await import('p-queue');
    const zkQueue = new PQueue({
        concurrency: zkProofConcurrency,
        autoStart: true,
    });
    const packetsToProve = [];
    logger = (logger || logger_1.logger).child({ module: 'zk', zkEngine: zkEngine });
    let zkChunksToProve = 0;
    return {
        /**
         * Adds the given packet to the list of packets to
         * generate ZK proofs for.
         *
         * Call `generateProofs()` to finally generate the proofs
         */
        async addPacketToProve(packet, { redactedPlaintext, toprfs }, onGeneratedProofs) {
            if (packet.type === 'plaintext') {
                throw new Error('Cannot generate proof for plaintext');
            }
            const alg = (0, generics_1.getZkAlgorithmForCipherSuite)(cipherSuite);
            const chunkSizeBytes = getChunkSizeBytes(alg);
            //const { redactedPlaintext } = reveal
            const key = await tls_1.crypto.exportKey(packet.encKey);
            const iv = packet.iv;
            const ciphertext = (0, generics_1.getPureCiphertext)(packet.ciphertext, cipherSuite);
            const chunks = Math.ceil(ciphertext.length / chunkSizeBytes);
            const packetToProve = {
                onGeneratedProofs,
                algorithm: alg,
                proofsToGenerate: [],
                iv: packet.fixedIv,
            };
            const chunksDone = new Set();
            // first we'll handle all TOPRF blocks
            // we do these first, because they can span multiple chunks
            // & we need to be able to span the right chunks
            for (const toprf of toprfs || []) {
                const startChunk = Math.floor(toprf.dataLocation.fromIndex / chunkSizeBytes);
                if (chunksDone.has(startChunk)) {
                    throw new error_1.AttestorError('ERROR_BAD_REQUEST', `Chunk ${startChunk} contains more than one TOPRF,`
                        + ' which is not supported');
                }
                addProofToGenerate(startChunk, {
                    ...toprf,
                    dataLocation: {
                        ...toprf.dataLocation,
                        fromIndex: toprf.dataLocation.fromIndex % chunkSizeBytes
                    }
                });
            }
            for (let i = 0; i < chunks; i++) {
                // ignore any TOPRF chunks
                if (chunksDone.has(i)) {
                    continue;
                }
                addProofToGenerate(i);
            }
            // generate proofs in order of start index
            packetToProve.proofsToGenerate
                .sort((a, b) => a.startIdx - b.startIdx);
            packetsToProve.push(packetToProve);
            function addProofToGenerate(offsetChunks, toprf) {
                chunksDone.add(offsetChunks);
                const proofParams = getProofGenerationParamsForChunk(alg, {
                    key,
                    iv,
                    ciphertext,
                    redactedPlaintext,
                    offsetChunks,
                    toprf,
                });
                if (!proofParams) {
                    return;
                }
                packetToProve.proofsToGenerate.push(proofParams);
                zkChunksToProve += 1;
                if (zkChunksToProve > maxZkChunks) {
                    throw new Error('Too many chunks to prove:'
                        + ` ${zkChunksToProve} > ${maxZkChunks}`);
                }
            }
        },
        getTotalChunksToProve() {
            return zkChunksToProve;
        },
        async generateProofs(onChunkDone) {
            var _a;
            if (!packetsToProve.length) {
                return;
            }
            const start = Date.now();
            const tasks = [];
            for (const { onGeneratedProofs, algorithm, proofsToGenerate } of packetsToProve) {
                const proofs = [];
                let proofsLeft = proofsToGenerate.length;
                for (const proofToGen of proofsToGenerate) {
                    tasks.push(zkQueue.add(async () => {
                        const proof = await generateProofForChunk(algorithm, proofToGen);
                        onChunkDone === null || onChunkDone === void 0 ? void 0 : onChunkDone();
                        proofs.push(proof);
                        proofsLeft -= 1;
                        if (proofsLeft === 0) {
                            onGeneratedProofs(proofs);
                        }
                    }, { throwOnTimeout: true }));
                }
            }
            await Promise.all(tasks);
            logger === null || logger === void 0 ? void 0 : logger.info({
                durationMs: Date.now() - start,
                chunks: zkChunksToProve,
            }, 'generated ZK proofs');
            // reset the packets to prove
            packetsToProve.splice(0, packetsToProve.length);
            zkChunksToProve = 0;
            // release ZK resources to free up memory
            const alg = (0, generics_1.getZkAlgorithmForCipherSuite)(cipherSuite);
            const zkOperator = await getZkOperatorForAlgorithm(alg);
            (_a = zkOperator.release) === null || _a === void 0 ? void 0 : _a.call(zkOperator);
        },
    };
    async function generateProofForChunk(algorithm, { startIdx, redactedPlaintext, privateInput, publicInput, toprf, }) {
        const operator = toprf
            ? getOprfOperatorForAlgorithm(algorithm)
            : getZkOperatorForAlgorithm(algorithm);
        const proof = await (0, zk_symmetric_crypto_1.generateProof)({
            algorithm,
            privateInput,
            publicInput,
            operator,
            logger,
            ...(toprf
                ? {
                    toprf: {
                        pos: toprf.dataLocation.fromIndex,
                        len: toprf.dataLocation.length,
                        output: toprf.nullifier,
                        responses: toprf.responses,
                        domainSeparator: config_1.TOPRF_DOMAIN_SEPARATOR
                    },
                    mask: toprf.mask,
                }
                : {})
        });
        logger === null || logger === void 0 ? void 0 : logger.debug({ startIdx }, 'generated proof for chunk');
        return {
            // backwards compatibility
            proofJson: '',
            proofData: typeof proof.proofData === 'string'
                ? (0, tls_1.strToUint8Array)(proof.proofData)
                : proof.proofData,
            toprf,
            decryptedRedactedCiphertext: proof.plaintext,
            redactedPlaintext,
            startIdx
        };
    }
    function getZkOperatorForAlgorithm(algorithm) {
        return (zkOperators === null || zkOperators === void 0 ? void 0 : zkOperators[algorithm])
            || makeDefaultZkOperator(algorithm, zkEngine, logger);
    }
    function getOprfOperatorForAlgorithm(algorithm) {
        return (oprfOperators === null || oprfOperators === void 0 ? void 0 : oprfOperators[algorithm])
            || makeDefaultOPRFOperator(algorithm, zkEngine, logger);
    }
}
/**
 * Verify the given ZK proof
 */
async function verifyZkPacket({ cipherSuite, ciphertext, zkReveal, zkOperators, oprfOperators, logger = logger_1.logger, zkEngine = 'snarkjs', iv, recordNumber }) {
    if (!zkReveal) {
        throw new Error('No ZK reveal');
    }
    const { proofs } = zkReveal;
    const algorithm = (0, generics_1.getZkAlgorithmForCipherSuite)(cipherSuite);
    const recordIV = (0, generics_1.getRecordIV)(ciphertext, cipherSuite);
    ciphertext = (0, generics_1.getPureCiphertext)(ciphertext, cipherSuite);
    /**
     * to verify if the user has given us the correct redacted plaintext,
     * and isn't providing plaintext that they haven't proven they have
     * we start with a fully redacted plaintext, and then replace the
     * redacted parts with the plaintext that the user has provided
     * in the proofs
     */
    const realRedactedPlaintext = new Uint8Array(ciphertext.length).fill(redactions_1.REDACTION_CHAR_CODE);
    const alg = (0, generics_1.getZkAlgorithmForCipherSuite)(cipherSuite);
    const chunkSizeBytes = getChunkSizeBytes(alg);
    await Promise.all(proofs.map(async (proof, i) => {
        try {
            await verifyProofPacket(proof);
        }
        catch (e) {
            e.message += ` (chunk ${i}, startIdx ${proof.startIdx})`;
            throw e;
        }
    }));
    return { redactedPlaintext: realRedactedPlaintext };
    async function verifyProofPacket({ proofData, proofJson, decryptedRedactedCiphertext, redactedPlaintext, startIdx, toprf, }) {
        var _a, _b, _c;
        // get the ciphertext chunk we received from the server
        // the ZK library, will verify that the decrypted redacted
        // ciphertext matches the ciphertext received from the server
        const ciphertextChunk = ciphertext.slice(startIdx, startIdx + redactedPlaintext.length);
        // redact ciphertext if plaintext is redacted
        // to prepare for decryption in ZK circuit
        // the ZK circuit will take in the redacted ciphertext,
        // which shall produce the redacted plaintext
        for (let i = 0; i < ciphertextChunk.length; i++) {
            if (redactedPlaintext[i] === redactions_1.REDACTION_CHAR_CODE) {
                ciphertextChunk[i] = redactions_1.REDACTION_CHAR_CODE;
            }
        }
        // redact OPRF indices -- because they'll incorrectly
        // be marked as incongruent
        let comparePlaintext = redactedPlaintext;
        if (toprf) {
            comparePlaintext = new Uint8Array(redactedPlaintext);
            for (let i = 0; i < toprf.dataLocation.length; i++) {
                comparePlaintext[i + toprf.dataLocation.fromIndex] = redactions_1.REDACTION_CHAR_CODE;
            }
            // the transcript will contain only the stringified
            // nullifier. So here, we'll compare the provable
            // binary nullifier with the stringified nullifier
            // that the user has provided
            const nulliferStr = (0, redactions_1.binaryHashToStr)(toprf.nullifier, toprf.dataLocation.length);
            const txtHash = redactedPlaintext.slice((_a = toprf.dataLocation) === null || _a === void 0 ? void 0 : _a.fromIndex, ((_b = toprf.dataLocation) === null || _b === void 0 ? void 0 : _b.fromIndex)
                + ((_c = toprf.dataLocation) === null || _c === void 0 ? void 0 : _c.length));
            if ((0, generics_1.uint8ArrayToStr)(txtHash) !== nulliferStr
                .slice(0, txtHash.length)) {
                throw new Error('OPRF nullifier not congruent');
            }
        }
        if (!(0, redactions_1.isRedactionCongruent)(comparePlaintext, decryptedRedactedCiphertext)) {
            throw new Error('redacted ciphertext not congruent');
        }
        const chunkIndex = startIdx / chunkSizeBytes;
        let nonce = (0, tls_1.concatenateUint8Arrays)([iv, recordIV]);
        if (!recordIV.length) {
            nonce = (0, tls_1.generateIV)(nonce, recordNumber);
        }
        await (0, zk_symmetric_crypto_1.verifyProof)({
            proof: {
                algorithm,
                proofData: proofData.length
                    ? proofData
                    : (0, tls_1.strToUint8Array)(proofJson),
                plaintext: decryptedRedactedCiphertext,
            },
            publicInput: {
                ciphertext: ciphertextChunk,
                iv: nonce,
                offset: chunkIndex
            },
            logger,
            ...(toprf
                ? {
                    operator: getOprfOperator(),
                    toprf: {
                        pos: toprf.dataLocation.fromIndex,
                        len: toprf.dataLocation.length,
                        domainSeparator: config_1.TOPRF_DOMAIN_SEPARATOR,
                        output: toprf.nullifier,
                        responses: toprf.responses,
                    }
                }
                : { operator: getZkOperator() })
        });
        logger === null || logger === void 0 ? void 0 : logger.debug({ startIdx, endIdx: startIdx + redactedPlaintext.length }, 'verified proof');
        realRedactedPlaintext.set(redactedPlaintext, startIdx);
    }
    function getZkOperator() {
        return (zkOperators === null || zkOperators === void 0 ? void 0 : zkOperators[algorithm])
            || makeDefaultZkOperator(algorithm, zkEngine, logger);
    }
    function getOprfOperator() {
        return (oprfOperators === null || oprfOperators === void 0 ? void 0 : oprfOperators[algorithm])
            || makeDefaultOPRFOperator(algorithm, zkEngine, logger);
    }
}
function getChunkSizeBytes(alg) {
    const { chunkSize, bitsPerWord } = zk_symmetric_crypto_1.CONFIG[alg];
    return chunkSize * bitsPerWord / 8;
}
const zkEngines = {};
const oprfEngines = {};
const operatorMakers = {
    'snarkjs': zk_symmetric_crypto_1.makeSnarkJsZKOperator,
    'gnark': zk_symmetric_crypto_1.makeGnarkZkOperator,
};
const OPRF_OPERATOR_MAKERS = {
    'gnark': zk_symmetric_crypto_1.makeGnarkOPRFOperator
};
function makeDefaultZkOperator(algorithm, zkEngine, logger) {
    let zkOperators = zkEngines[zkEngine];
    if (!zkOperators) {
        zkEngines[zkEngine] = {};
        zkOperators = zkEngines[zkEngine];
    }
    if (!zkOperators[algorithm]) {
        const isNode = (0, env_1.detectEnvironment)() === 'node';
        const opType = isNode ? 'local' : 'remote';
        logger === null || logger === void 0 ? void 0 : logger.info({ type: opType, algorithm }, 'fetching zk operator');
        const fetcher = opType === 'local'
            ? (0, zk_symmetric_crypto_1.makeLocalFileFetch)()
            : (0, zk_symmetric_crypto_1.makeRemoteFileFetch)({
                baseUrl: config_1.DEFAULT_REMOTE_FILE_FETCH_BASE_URL,
            });
        const maker = operatorMakers[zkEngine];
        if (!maker) {
            throw new Error(`No ZK operator maker for ${zkEngine}`);
        }
        zkOperators[algorithm] = maker({ algorithm, fetcher });
    }
    return zkOperators[algorithm];
}
function makeDefaultOPRFOperator(algorithm, zkEngine, logger) {
    let operators = oprfEngines[zkEngine];
    if (!operators) {
        oprfEngines[zkEngine] = {};
        operators = oprfEngines[zkEngine];
    }
    if (!operators[algorithm]) {
        const isNode = (0, env_1.detectEnvironment)() === 'node';
        const type = isNode ? 'local' : 'remote';
        logger === null || logger === void 0 ? void 0 : logger.info({ type, algorithm }, 'fetching oprf operator');
        const fetcher = type === 'local'
            ? (0, zk_symmetric_crypto_1.makeLocalFileFetch)()
            : (0, zk_symmetric_crypto_1.makeRemoteFileFetch)({
                baseUrl: config_1.DEFAULT_REMOTE_FILE_FETCH_BASE_URL,
            });
        const maker = OPRF_OPERATOR_MAKERS[zkEngine];
        if (!maker) {
            throw new Error(`No OPRF operator maker for ${zkEngine}`);
        }
        operators[algorithm] = maker({ algorithm, fetcher });
    }
    return operators[algorithm];
}
function getEngineString(engine) {
    if (engine === api_1.ZKProofEngine.ZK_ENGINE_GNARK) {
        return 'gnark';
    }
    if (engine === api_1.ZKProofEngine.ZK_ENGINE_SNARKJS) {
        return 'snarkjs';
    }
    throw new Error(`Unknown ZK engine: ${engine}`);
}
function getEngineProto(engine) {
    if (engine === 'gnark') {
        return api_1.ZKProofEngine.ZK_ENGINE_GNARK;
    }
    if (engine === 'snarkjs') {
        return api_1.ZKProofEngine.ZK_ENGINE_SNARKJS;
    }
    throw new Error(`Unknown ZK engine: ${engine}`);
}
function getProofGenerationParamsForChunk(algorithm, { key, iv, ciphertext, redactedPlaintext, offsetChunks, toprf, }) {
    const chunkSize = getChunkSizeBytes(algorithm);
    const startIdx = offsetChunks * chunkSize;
    const endIdx = (offsetChunks + 1) * chunkSize;
    const ciphertextChunk = ciphertext
        .slice(startIdx, endIdx);
    const plaintextChunk = redactedPlaintext
        .slice(startIdx, endIdx);
    if ((0, redactions_1.isFullyRedacted)(plaintextChunk)) {
        return;
    }
    // redact ciphertext if plaintext is redacted
    // to prepare for decryption in ZK circuit
    // the ZK circuit will take in the redacted ciphertext,
    // which shall produce the redacted plaintext
    for (let i = 0; i < ciphertextChunk.length; i++) {
        if (plaintextChunk[i] === redactions_1.REDACTION_CHAR_CODE) {
            ciphertextChunk[i] = redactions_1.REDACTION_CHAR_CODE;
        }
    }
    return {
        startIdx,
        redactedPlaintext: plaintextChunk,
        privateInput: { key },
        publicInput: { ciphertext: ciphertextChunk, iv, offset: offsetChunks },
        toprf
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiemsuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvemsudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUE2RUEsb0RBcVBDO0FBS0Qsd0NBMktDO0FBNEJELHNEQThCQztBQUVELDBEQThCQztBQUVELDBDQVVDO0FBR0Qsd0NBVUM7QUFybUJELDhDQUErRztBQUMvRyw4RUFleUQ7QUFDekQsdUNBQThIO0FBQzlILHVDQUEwSDtBQUUxSCx1Q0FBaUU7QUFDakUsMkNBQStDO0FBQy9DLGlEQUFrSDtBQUNsSCw2Q0FBbUQ7QUFDbkQscURBQWtIO0FBZ0RsSCxNQUFNLGNBQWMsR0FBRyxDQUFDLENBQ3ZCLElBQUEsb0JBQWMsRUFBQyxnQkFBZ0IsQ0FBQztPQUM3QiwrQkFBc0IsQ0FDekIsQ0FBQTtBQUVNLEtBQUssVUFBVSxvQkFBb0IsQ0FDekMsRUFDQyxXQUFXLEVBQ1gsYUFBYSxFQUNiLE1BQU0sR0FBRyxlQUFNLEVBQ2Ysa0JBQWtCLEdBQUcsY0FBYyxFQUNuQyxXQUFXLEdBQUcsc0JBQWEsRUFDM0IsV0FBVyxFQUNYLFFBQVEsR0FBRyxTQUFTLEVBQ0M7SUFHdEIsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQTtJQUNuRCxNQUFNLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQztRQUMxQixXQUFXLEVBQUUsa0JBQWtCO1FBQy9CLFNBQVMsRUFBRSxJQUFJO0tBQ2YsQ0FBQyxDQUFBO0lBRUYsTUFBTSxjQUFjLEdBQXNCLEVBQUUsQ0FBQTtJQUU1QyxNQUFNLEdBQUcsQ0FBQyxNQUFNLElBQUksZUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQTtJQUN2RSxJQUFJLGVBQWUsR0FBRyxDQUFDLENBQUE7SUFFdkIsT0FBTztRQUNOOzs7OztXQUtHO1FBQ0gsS0FB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