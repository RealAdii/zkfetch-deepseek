"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tls_1 = require("@reclaimprotocol/tls");
const utils_1 = require("../utils");
const ZK_CIPHER_SUITES = [
    'TLS_CHACHA20_POLY1305_SHA256',
    'TLS_AES_128_GCM_SHA256',
    'TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384',
];
const ZK_ENGINES = [
    'gnark',
    'snarkjs'
];
jest.setTimeout(90000); // 90s
describe('Redaction Tests', () => {
    it('should correctly redact blocks', async () => {
        const vectors = [
            {
                input: [
                    'hell',
                    'o world'
                ],
                output: [
                    'h***',
                    '* world'
                ],
                redactions: [
                    { fromIndex: 1, toIndex: 5 }
                ]
            },
            {
                input: [
                    'hell',
                    'o world'
                ],
                output: [
                    // first block is completely
                    // redacted, so it won't be included
                    '* world'
                ],
                redactions: [
                    { fromIndex: 0, toIndex: 5 }
                ]
            },
            {
                input: [
                    'hello',
                    'how',
                    'do',
                    'you',
                    'do'
                ],
                output: [
                    'he**o',
                    'd*',
                    'y*u',
                    'do'
                ],
                redactions: [
                    { fromIndex: 2, toIndex: 4 },
                    { fromIndex: 5, toIndex: 8 },
                    { fromIndex: 9, toIndex: 10 },
                    { fromIndex: 11, toIndex: 12 }
                ]
            }
        ];
        for (const { input, output, redactions } of vectors) {
            const realOutput = await (0, utils_1.getBlocksToReveal)(input.map(i => ({ plaintext: Buffer.from(i) })), () => redactions, () => {
                throw new Error('should not call this');
            });
            if (realOutput === 'all') {
                fail('should not return "all"');
                continue;
            }
            expect(realOutput).toHaveLength(output.length);
            for (const [i, element] of output.entries()) {
                expect((0, utils_1.uint8ArrayToStr)(realOutput[i].redactedPlaintext)).toEqual(element);
            }
        }
    });
    it('should correctly hash blocks', async () => {
        const nullifer = (0, tls_1.strToUint8Array)('abcdefg');
        const base64Nullifier = Buffer.from(nullifer).toString('base64');
        const vectors = [
            {
                input: [
                    'hell',
                    'o world'
                ],
                output: [
                    'h' + base64Nullifier.slice(0, 3),
                    base64Nullifier.slice(3, 4) + ' world'
                ],
                redactions: [
                    { fromIndex: 1, toIndex: 5, hash: 'oprf' }
                ]
            },
            {
                input: [
                    'hell',
                    'o world'
                ],
                output: [
                    base64Nullifier.slice(0, 4),
                    base64Nullifier.slice(4, 5) + ' world'
                ],
                redactions: [
                    { fromIndex: 0, toIndex: 5, hash: 'oprf' }
                ]
            },
        ];
        for (const { input, output, redactions } of vectors) {
            const realOutput = await (0, utils_1.getBlocksToReveal)(input.map(i => ({ plaintext: Buffer.from(i) })), () => redactions, async () => ({
                dataLocation: undefined,
                nullifier: nullifer,
                responses: [],
                mask: (0, tls_1.strToUint8Array)('mask'),
                plaintext: (0, tls_1.strToUint8Array)('abcdefg')
            }));
            if (realOutput === 'all') {
                fail('should not return "all"');
            }
            expect(realOutput).toHaveLength(output.length);
            for (const [i, element] of output.entries()) {
                expect((0, utils_1.uint8ArrayToStr)(realOutput[i].redactedPlaintext)).toEqual(element);
            }
        }
    });
});
describe.each(ZK_CIPHER_SUITES)('[%s] should generate ZK proof for some ciphertext', (cipherSuite) => {
    describe.each(ZK_ENGINES)('[%s]', (zkEngine) => {
        it(zkEngine + '-' + cipherSuite, async () => {
            const alg = cipherSuite.includes('CHACHA20')
                ? 'CHACHA20-POLY1305'
                : (cipherSuite.includes('AES_256_GCM')
                    ? 'AES-256-GCM'
                    : 'AES-128-GCM');
            const keylength = alg === 'AES-128-GCM' ? 16 : 32;
            const key = Buffer.alloc(keylength, 0);
            key[0] = 1;
            key[3] = 4;
            const { ivLength: fixedIvLength, } = tls_1.SUPPORTED_CIPHER_SUITE_MAP[cipherSuite];
            const fixedIv = Buffer.alloc(fixedIvLength, 0);
            fixedIv[0] = 1;
            fixedIv[3] = 4;
            const encKey = await tls_1.crypto.importKey(alg, key);
            const vectors = [
                {
                    plaintext: 'My cool API secret is "my name jeff". Please don\'t reveal it',
                    redactions: [
                        { fromIndex: 23, toIndex: 35 }
                    ]
                },
                {
                    plaintext: `lorem ipsum dolor sit amet, consectetur adipiscing elit,
				sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
				Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris
				nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
				cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat
				cupidatat non proident, sunt in culpa qui officia deserunt mollit anim
				id est laborum`,
                    redactions: [
                        { fromIndex: 5, toIndex: 15 },
                    ]
                }
            ];
            const proofGenerator = await (0, utils_1.makeZkProofGenerator)({
                logger: utils_1.logger,
                cipherSuite,
                zkEngine: zkEngine
            });
            for (const { plaintext, redactions } of vectors) {
                const plaintextArr = Buffer.from(plaintext);
                const redactedPlaintext = (0, utils_1.redactSlices)(plaintextArr, redactions);
                // ensure redaction fn kinda works at least
                expect(redactedPlaintext).not.toEqual(plaintextArr);
                const { ciphertext, iv } = await (0, tls_1.encryptWrappedRecord)(plaintextArr, {
                    key: encKey,
                    iv: fixedIv,
                    recordNumber: 1234,
                    recordHeaderOpts: {
                        type: 'WRAPPED_RECORD'
                    },
                    cipherSuite,
                    version: cipherSuite.includes('ECDHE_')
                        ? 'TLS1_2'
                        : 'TLS1_3',
                });
                const packet = {
                    type: 'ciphertext',
                    encKey,
                    iv,
                    recordNumber: 1234,
                    plaintext: plaintextArr,
                    ciphertext,
                    fixedIv: fixedIv,
                    data: ciphertext
                };
                let proofs;
                await proofGenerator.addPacketToProve(packet, {
                    type: 'zk',
                    redactedPlaintext,
                }, p => proofs = p);
                await proofGenerator.generateProofs();
                const x = await (0, utils_1.verifyZkPacket)({
                    ciphertext,
                    zkReveal: { proofs: proofs },
                    logger: utils_1.logger,
                    cipherSuite,
                    zkEngine: zkEngine,
                    recordNumber: 1234,
                    iv: fixedIv
                });
                expect(redactedPlaintext).toEqual(x.redactedPlaintext);
            }
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC56ay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZXN0cy90ZXN0LnprLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsOENBQTZIO0FBSTdILHFDQU9rQjtBQUVsQixNQUFNLGdCQUFnQixHQUFrQjtJQUN2Qyw4QkFBOEI7SUFDOUIsd0JBQXdCO0lBQ3hCLHlDQUF5QztDQUN6QyxDQUFBO0FBRUQsTUFBTSxVQUFVLEdBQWU7SUFDOUIsT0FBTztJQUNQLFNBQVM7Q0FDVCxDQUFBO0FBUUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFNLENBQUMsQ0FBQSxDQUFDLE1BQU07QUFFOUIsUUFBUSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtJQUVoQyxFQUFFLENBQUMsZ0NBQWdDLEVBQUUsS0FBSyxJQUFHLEVBQUU7UUFDOUMsTUFBTSxPQUFPLEdBQTBCO1lBQ3RDO2dCQUNDLEtBQUssRUFBRTtvQkFDTixNQUFNO29CQUNOLFNBQVM7aUJBQ1Q7Z0JBQ0QsTUFBTSxFQUFFO29CQUNQLE1BQU07b0JBQ04sU0FBUztpQkFDVDtnQkFDRCxVQUFVLEVBQUU7b0JBQ1gsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUU7aUJBQzVCO2FBQ0Q7WUFDRDtnQkFDQyxLQUFLLEVBQUU7b0JBQ04sTUFBTTtvQkFDTixTQUFTO2lCQUNUO2dCQUNELE1BQU0sRUFBRTtvQkFDUCw0QkFBNEI7b0JBQzVCLG9DQUFvQztvQkFDcEMsU0FBUztpQkFDVDtnQkFDRCxVQUFVLEVBQUU7b0JBQ1gsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUU7aUJBQzVCO2FBQ0Q7WUFDRDtnQkFDQyxLQUFLLEVBQUU7b0JBQ04sT0FBTztvQkFDUCxLQUFLO29CQUNMLElBQUk7b0JBQ0osS0FBSztvQkFDTCxJQUFJO2lCQUNKO2dCQUNELE1BQU0sRUFBRTtvQkFDUCxPQUFPO29CQUNQLElBQUk7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