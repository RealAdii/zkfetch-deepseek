"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertValidClaimRequest = assertValidClaimRequest;
exports.assertValidProviderTranscript = assertValidProviderTranscript;
exports.assertTranscriptsMatch = assertTranscriptsMatch;
exports.decryptTranscript = decryptTranscript;
exports.getWithoutHeader = getWithoutHeader;
const tls_1 = require("@reclaimprotocol/tls");
const api_1 = require("../../proto/api");
const providers_1 = require("../../providers");
const generics_1 = require("../../server/utils/generics");
const process_handshake_1 = require("../../server/utils/process-handshake");
const utils_1 = require("../../utils");
const signatures_1 = require("../../utils/signatures");
/**
 * Asserts that the claim request is valid.
 *
 * 1. We begin by verifying the signature of the claim request.
 * 2. Next, we produce the transcript of the TLS exchange
 * from the proofs provided by the client.
 * 3. We then pull the provider the client is trying to claim
 * from
 * 4. We then use the provider's verification function to verify
 *  whether the claim is valid.
 *
 * If any of these steps fail, we throw an error.
 */
async function assertValidClaimRequest(request, metadata, logger) {
    var _a;
    const { data, signatures: { requestSignature } = {}, zkEngine, fixedServerIV, fixedClientIV } = request;
    if (!data) {
        throw new utils_1.AttestorError('ERROR_INVALID_CLAIM', 'No info provided on claim request');
    }
    if (!(requestSignature === null || requestSignature === void 0 ? void 0 : requestSignature.length)) {
        throw new utils_1.AttestorError('ERROR_INVALID_CLAIM', 'No signature provided on claim request');
    }
    // verify request signature
    const serialisedReq = api_1.ClaimTunnelRequest
        .encode({ ...request, signatures: undefined })
        .finish();
    const { verify: verifySig } = signatures_1.SIGNATURES[metadata.signatureType];
    const verified = await verifySig(serialisedReq, requestSignature, data.owner);
    if (!verified) {
        throw new utils_1.AttestorError('ERROR_INVALID_CLAIM', 'Invalid signature on claim request');
    }
    const receipt = await decryptTranscript(request.transcript, logger, zkEngine === api_1.ZKProofEngine.ZK_ENGINE_GNARK ? 'gnark' : 'snarkjs', fixedServerIV, fixedClientIV);
    const reqHost = (_a = request.request) === null || _a === void 0 ? void 0 : _a.host;
    if (receipt.hostname !== reqHost) {
        throw new Error(`Expected server name ${reqHost}, got ${receipt.hostname}`);
    }
    // get all application data messages
    const applData = (0, utils_1.extractApplicationDataFromTranscript)(receipt);
    const newData = await assertValidProviderTranscript(applData, data, logger);
    if (newData !== data) {
        logger.info({ newData }, 'updated claim info');
    }
    return newData;
}
/**
 * Verify that the transcript contains a valid claim
 * for the provider.
 */
async function assertValidProviderTranscript(applData, info, logger) {
    var _a;
    const providerName = info.provider;
    const provider = providers_1.providers[providerName];
    if (!provider) {
        throw new utils_1.AttestorError('ERROR_INVALID_CLAIM', `Unsupported provider: ${providerName}`);
    }
    const params = (0, generics_1.niceParseJsonObject)(info.parameters, 'params');
    const ctx = (0, generics_1.niceParseJsonObject)(info.context, 'context');
    (0, utils_1.assertValidateProviderParams)(providerName, params);
    const rslt = await provider.assertValidProviderReceipt(applData, params, logger);
    const extractedParameters = (rslt === null || rslt === void 0 ? void 0 : rslt.extractedParameters) || {};
    if (!Object.keys(extractedParameters).length) {
        return info;
    }
    const newInfo = { ...info };
    ctx.extractedParameters = extractedParameters;
    ctx.providerHash = (0, utils_1.hashProviderParams)(params);
    newInfo.context = (_a = (0, utils_1.canonicalStringify)(ctx)) !== null && _a !== void 0 ? _a : '';
    return newInfo;
}
/**
 * Verify that the transcript provided by the client
 * matches the transcript of the tunnel, the server
 * has created.
 */
function assertTranscriptsMatch(clientTranscript, tunnelTranscript) {
    const clientSends = (0, tls_1.concatenateUint8Arrays)(clientTranscript
        .filter(m => m.sender === api_1.TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT)
        .map(m => m.message));
    const tunnelSends = (0, tls_1.concatenateUint8Arrays)(tunnelTranscript
        .filter(m => m.sender === 'client')
        .map(m => m.message));
    if (!(0, tls_1.areUint8ArraysEqual)(clientSends, tunnelSends)) {
        throw utils_1.AttestorError.badRequest('Outgoing messages from client do not match the tunnel transcript');
    }
    const clientRecvs = (0, tls_1.concatenateUint8Arrays)(clientTranscript
        .filter(m => m.sender === api_1.TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER)
        .map(m => m.message));
    const tunnelRecvs = (0, tls_1.concatenateUint8Arrays)(tunnelTranscript
        .filter(m => m.sender === 'server')
        .map(m => m.message))
        // We only need to compare the first N messages
        // that the client claims to have received
        // the rest are not relevant -- so even if they're
        // not present in the tunnel transcript, it's fine
        .slice(0, clientRecvs.length);
    if (!(0, tls_1.areUint8ArraysEqual)(clientRecvs, tunnelRecvs)) {
        throw utils_1.AttestorError.badRequest('Incoming messages from server do not match the tunnel transcript');
    }
}
async function decryptTranscript(transcript, logger, zkEngine, serverIV, clientIV) {
    const { tlsVersion, cipherSuite, hostname, nextMsgIndex } = await (0, process_handshake_1.processHandshake)(transcript, logger);
    let clientRecordNumber = tlsVersion === 'TLS1_3' ? -1 : 0; // TLS 1.3 has already one record encrypted at this point
    let serverRecordNumber = clientRecordNumber;
    transcript = transcript.slice(nextMsgIndex);
    const decryptedTranscript = [];
    for (const [i, { sender, message, reveal: { zkReveal, directReveal } = {} }] of transcript.entries()) {
        //start with first message after last handshake message
        await getDecryptedMessage(sender, message, directReveal, zkReveal, i);
    }
    return {
        transcript: decryptedTranscript,
        hostname: hostname,
        tlsVersion: tlsVersion,
    };
    async function getDecryptedMessage(sender, message, directReveal, zkReveal, i) {
        var _a, _b;
        try {
            const isServer = sender === api_1.TranscriptMessageSenderType
                .TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER;
            const recordHeader = message.slice(0, 5);
            const content = getWithoutHeader(message);
            if (isServer) {
                serverRecordNumber++;
            }
            else {
                clientRecordNumber++;
            }
            let redacted = true;
            let plaintext = undefined;
            let plaintextLength;
            if ((_a = directReveal === null || directReveal === void 0 ? void 0 : directReveal.key) === null || _a === void 0 ? void 0 : _a.length) {
                const result = await (0, utils_1.decryptDirect)(directReveal, cipherSuite, recordHeader, tlsVersion, content);
                plaintext = result.plaintext;
                redacted = false;
                plaintextLength = plaintext.length;
            }
            else if ((_b = zkReveal === null || zkReveal === void 0 ? void 0 : zkReveal.proofs) === null || _b === void 0 ? void 0 : _b.length) {
                const result = await (0, utils_1.verifyZkPacket)({
                    ciphertext: content,
                    zkReveal,
                    logger,
                    cipherSuite,
                    zkEngine: zkEngine,
                    iv: sender === api_1.TranscriptMessageSenderType
                        .TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER
                        ? serverIV
                        : clientIV,
                    recordNumber: isServer
                        ? serverRecordNumber
                        : clientRecordNumber
                });
                plaintext = result.redactedPlaintext;
                redacted = false;
                plaintextLength = plaintext.length;
            }
            else {
                plaintext = content;
                plaintextLength = plaintext.length;
            }
            decryptedTranscript.push({
                sender: sender === api_1.TranscriptMessageSenderType
                    .TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT
                    ? 'client'
                    : 'server',
                redacted,
                message: plaintext,
                recordHeader,
                plaintextLength,
            });
        }
        catch (error) {
            throw new utils_1.AttestorError('ERROR_INVALID_CLAIM', `error in handling packet at idx ${i}: ${error}`, {
                packetIdx: i,
                error: error,
            });
        }
    }
}
function getWithoutHeader(message) {
    // strip the record header (xx 03 03 xx xx)
    return message.slice(5);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXJ0LXZhbGlkLWNsYWltLXJlcXVlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc2VydmVyL3V0aWxzL2Fzc2VydC12YWxpZC1jbGFpbS1yZXF1ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBOENBLDBEQW9FQztBQU1ELHNFQW9DQztBQU9ELHdEQTJDQztBQUVELDhDQTZHQztBQUVELDRDQUdDO0FBbFVELDhDQUc2QjtBQUU3Qix1Q0FRc0I7QUFDdEIsNkNBQXlDO0FBQ3pDLHdEQUErRDtBQUMvRCwwRUFBcUU7QUFRckUscUNBTWtCO0FBQ2xCLHFEQUFpRDtBQUVqRDs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSSxLQUFLLFVBQVUsdUJBQXVCLENBQzVDLE9BQTJCLEVBQzNCLFFBQXFCLEVBQ3JCLE1BQWM7O0lBRWQsTUFBTSxFQUNMLElBQUksRUFDSixVQUFVLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLEVBQUUsRUFDckMsUUFBUSxFQUNSLGFBQWEsRUFDYixhQUFhLEVBQ2IsR0FBRyxPQUFPLENBQUE7SUFDWCxJQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDVixNQUFNLElBQUkscUJBQWEsQ0FDdEIscUJBQXFCLEVBQ3JCLG1DQUFtQyxDQUNuQyxDQUFBO0lBQ0YsQ0FBQztJQUVELElBQUcsQ0FBQyxDQUFBLGdCQUFnQixhQUFoQixnQkFBZ0IsdUJBQWhCLGdCQUFnQixDQUFFLE1BQU0sQ0FBQSxFQUFFLENBQUM7UUFDOUIsTUFBTSxJQUFJLHFCQUFhLENBQ3RCLHFCQUFxQixFQUNyQix3Q0FBd0MsQ0FDeEMsQ0FBQTtJQUNGLENBQUM7SUFFRCwyQkFBMkI7SUFDM0IsTUFBTSxhQUFhLEdBQUcsd0JBQWtCO1NBQ3RDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsQ0FBQztTQUM3QyxNQUFNLEVBQUUsQ0FBQTtJQUNWLE1BQU0sRUFBRSxNQUFNLEVBQUUs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