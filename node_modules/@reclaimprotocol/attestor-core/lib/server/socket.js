"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttestorServerSocket = void 0;
const message_handler_1 = require("../client/utils/message-handler");
const handlers_1 = require("../server/handlers");
const apm_1 = require("../server/utils/apm");
const generics_1 = require("../server/utils/generics");
const utils_1 = require("../utils");
const socket_base_1 = require("../utils/socket-base");
const util_1 = require("util");
class AttestorServerSocket extends socket_base_1.AttestorSocket {
    constructor(socket, sessionId, bgpListener, logger) {
        // @ts-ignore
        super(socket, {}, logger);
        this.sessionId = sessionId;
        this.bgpListener = bgpListener;
        this.tunnels = {};
        // handle RPC requests
        this.addEventListener('rpc-request', handleRpcRequest.bind(this));
        // forward packets to the appropriate tunnel
        this.addEventListener('tunnel-message', handleTunnelMessage.bind(this));
        // close all tunnels when the connection is terminated
        // since this tunnel can no longer be written to
        this.addEventListener('connection-terminated', () => {
            for (const tunnelId in this.tunnels) {
                const tunnel = this.tunnels[tunnelId];
                tunnel.close(new Error('WS session terminated'));
            }
        });
    }
    getTunnel(tunnelId) {
        const tunnel = this.tunnels[tunnelId];
        if (!tunnel) {
            throw new utils_1.AttestorError('ERROR_NOT_FOUND', `Tunnel "${tunnelId}" not found`);
        }
        return tunnel;
    }
    removeTunnel(tunnelId) {
        delete this.tunnels[tunnelId];
    }
    static async acceptConnection(socket, { req, logger, bgpListener }) {
        // promisify ws.send -- so the sendMessage method correctly
        // awaits the send operation
        const bindSend = socket.send.bind(socket);
        socket.send = (0, util_1.promisify)(bindSend);
        const sessionId = (0, utils_1.generateSessionId)();
        logger = logger.child({ sessionId });
        const client = new AttestorServerSocket(socket, sessionId, bgpListener, logger);
        try {
            const initMsgs = (0, generics_1.getInitialMessagesFromQuery)(req);
            logger.trace({ initMsgs: initMsgs.length }, 'new connection, validating...');
            for (const msg of initMsgs) {
                await message_handler_1.handleMessage.call(client, msg);
            }
            logger.debug('connection accepted');
        }
        catch (err) {
            logger.error({ err }, 'error in new connection');
            if (client.isOpen) {
                client.terminateConnection(err instanceof utils_1.AttestorError
                    ? err
                    : utils_1.AttestorError.badRequest(err.message));
            }
            return;
        }
        return client;
    }
}
exports.AttestorServerSocket = AttestorServerSocket;
async function handleTunnelMessage({ data: { tunnelId, message } }) {
    var _a;
    try {
        const tunnel = this.getTunnel(tunnelId);
        await tunnel.write(message);
    }
    catch (err) {
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error({
            err,
            tunnelId,
        }, 'error writing to tunnel');
    }
}
async function handleRpcRequest({ data: { data, requestId, respond, type } }) {
    var _a, _b;
    const logger = this.logger.child({
        rpc: type,
        requestId
    });
    const apm = (0, apm_1.getApm)();
    const tx = apm === null || apm === void 0 ? void 0 : apm.startTransaction(type);
    tx === null || tx === void 0 ? void 0 : tx.setLabel('requestId', requestId);
    tx === null || tx === void 0 ? void 0 : tx.setLabel('sessionId', this.sessionId.toString());
    const userId = (_b = (_a = this.metadata.auth) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.id;
    if (userId) {
        tx === null || tx === void 0 ? void 0 : tx.setLabel('authUserId', userId);
    }
    try {
        logger.debug({ data }, 'handling RPC request');
        const handler = handlers_1.HANDLERS[type];
        const res = await handler(data, { client: this, logger, tx });
        await respond(res);
        logger.debug({ res }, 'handled RPC request');
        tx === null || tx === void 0 ? void 0 : tx.setOutcome('success');
    }
    catch (err) {
        logger.error({ err }, 'error in RPC request');
        respond(utils_1.AttestorError.fromError(err));
        tx === null || tx === void 0 ? void 0 : tx.setOutcome('failure');
        apm === null || apm === void 0 ? void 0 : apm.captureError(err, { parent: tx });
    }
    finally {
        tx === null || tx === void 0 ? void 0 : tx.end();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29ja2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NlcnZlci9zb2NrZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0VBQWdFO0FBRWhFLGtEQUE4QztBQUM5Qyw4Q0FBNkM7QUFDN0Msd0RBQXVFO0FBRXZFLHFDQUE0RDtBQUM1RCx1REFBc0Q7QUFDdEQsK0JBQWdDO0FBR2hDLE1BQWEsb0JBQXFCLFNBQVEsNEJBQWM7SUFJdkQsWUFDQyxNQUFVLEVBQ0gsU0FBaUIsRUFDakIsV0FBb0MsRUFDM0MsTUFBYztRQUVkLGFBQWE7UUFDYixLQUFLLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQTtRQUxsQixjQUFTLEdBQVQsU0FBUyxDQUFRO1FBQ2pCLGdCQUFXLEdBQVgsV0FBVyxDQUF5QjtRQUw1QyxZQUFPLEdBQXFDLEVBQUUsQ0FBQTtRQVU3QyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtRQUNqRSw0Q0FBNEM7UUFDNUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixFQUFFLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFBO1FBQ3ZFLHNEQUFzRDtRQUN0RCxnREFBZ0Q7UUFDaEQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLHVCQUF1QixFQUFFLEdBQUcsRUFBRTtZQUNuRCxLQUFJLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDcEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtnQkFDckMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUE7WUFDakQsQ0FBQztRQUNGLENBQUMsQ0FBQyxDQUFBO0lBQ0gsQ0FB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O1FBQzVDLEVBQUUsYUFBRixFQUFFLHVCQUFGLEVBQUUsQ0FBRSxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUE7SUFDMUIsQ0FBQztJQUFDLE9BQU0sR0FBRyxFQUFFLENBQUM7UUFDYixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsc0JBQXNCLENBQUMsQ0FBQTtRQUM3QyxPQUFPLENBQUMscUJBQWEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtRQUNyQyxFQUFFLGFBQUYsRUFBRSx1QkFBRixFQUFFLENBQUUsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBRXpCLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxZQUFZLENBQUMsR0FBRyxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUE7SUFDdkMsQ0FBQztZQUFTLENBQUM7UUFDVixFQUFFLGFBQUYsRUFBRSx1QkFBRixFQUFFLENBQUUsR0FBRyxFQUFFLENBQUE7SUFDVixDQUFDO0FBQ0YsQ0FBQyJ9