"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTunnel = void 0;
const make_tcp_tunnel_1 = require("../../server/tunnels/make-tcp-tunnel");
const apm_1 = require("../../server/utils/apm");
const dns_1 = require("../../server/utils/dns");
const utils_1 = require("../../utils");
const createTunnel = async ({ id, ...opts }, { tx, logger, client }) => {
    var _a, _b, _c;
    if (client.tunnels[id]) {
        throw utils_1.AttestorError.badRequest(`Tunnel "${id}" already exists`);
    }
    const allowedHosts = (_c = (_b = (_a = client.metadata) === null || _a === void 0 ? void 0 : _a.auth) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.hostWhitelist;
    if ((allowedHosts === null || allowedHosts === void 0 ? void 0 : allowedHosts.length) && !allowedHosts.includes(opts.host)) {
        throw utils_1.AttestorError.badRequest(`Host "${opts.host}" not allowed by auth request`);
    }
    let cancelBgp;
    const apm = (0, apm_1.getApm)();
    const sessionTx = apm === null || apm === void 0 ? void 0 : apm.startTransaction('tunnelConnection', { childOf: tx });
    sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.setLabel('tunnelId', id.toString());
    sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.setLabel('hostPort', `${opts.host}:${opts.port}`);
    sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.setLabel('geoLocation', opts.geoLocation);
    try {
        const tunnel = await (0, make_tcp_tunnel_1.makeTcpTunnel)({
            ...opts,
            logger,
            onMessage(message) {
                if (!client.isOpen) {
                    logger.warn('client is closed, dropping message');
                    return;
                }
                client.sendMessage({
                    tunnelMessage: {
                        tunnelId: id,
                        message
                    }
                });
            },
            onClose(err) {
                cancelBgp === null || cancelBgp === void 0 ? void 0 : cancelBgp();
                if (err) {
                    apm === null || apm === void 0 ? void 0 : apm.captureError(err, { parent: sessionTx });
                    sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.setOutcome('failure');
                }
                else {
                    sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.setOutcome('success');
                }
                sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.end();
                if (!client.isOpen) {
                    return;
                }
                client.sendMessage({
                    tunnelDisconnectEvent: {
                        tunnelId: id,
                        error: err
                            ? utils_1.AttestorError
                                .fromError(err)
                                .toProto()
                            : undefined
                    }
                })
                    .catch(err => {
                    logger.error({ err }, 'failed to send tunnel disconnect event');
                });
            },
        });
        try {
            await checkForBgp(tunnel);
        }
        catch (err) {
            logger.warn({ err, host: opts.host }, 'failed to start BGP overlap check');
        }
        client.tunnels[id] = tunnel;
        return {};
    }
    catch (err) {
        apm === null || apm === void 0 ? void 0 : apm.captureError(err, { parent: sessionTx });
        sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.setOutcome('failure');
        sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.end();
        cancelBgp === null || cancelBgp === void 0 ? void 0 : cancelBgp();
        throw err;
    }
    async function checkForBgp(tunnel) {
        if (!client.bgpListener) {
            return;
        }
        // listen to all IPs for the host -- in case any of them
        // has a BGP announcement overlap, we'll close the tunnel
        // so the user can retry
        const ips = await (0, dns_1.resolveHostnames)(opts.host);
        cancelBgp = client.bgpListener.onOverlap(ips, (info) => {
            logger.warn({ info, host: opts.host }, 'BGP announcement overlap detected');
            // track how many times we've seen a BGP overlap
            sessionTx === null || sessionTx === void 0 ? void 0 : sessionTx.addLabels({ bgpOverlap: true, ...info });
            tunnel === null || tunnel === void 0 ? void 0 : tunnel.close(new utils_1.AttestorError('ERROR_BGP_ANNOUNCEMENT_OVERLAP', `BGP announcement overlap detected for ${opts.host}`));
        });
        logger.debug({ ips }, 'checking for BGP overlap');
    }
};
exports.createTunnel = createTunnel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlVHVubmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3NlcnZlci9oYW5kbGVycy9jcmVhdGVUdW5uZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsd0VBQWtFO0FBQ2xFLDhDQUE2QztBQUM3Qyw4Q0FBdUQ7QUFFdkQscUNBQXlDO0FBRWxDLE1BQU0sWUFBWSxHQUErQixLQUFLLEVBQzVELEVBQUUsRUFBRSxFQUFFLEdBQUcsSUFBSSxFQUFFLEVBQ2YsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxFQUNyQixFQUFFOztJQUNILElBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0scUJBQWEsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLGtCQUFrQixDQUFDLENBQUE7SUFDaEUsQ0FBQztJQUVELE1BQU0sWUFBWSxHQUFHLE1BQUEsTUFBQSxNQUFBLE1BQU0sQ0FBQyxRQUFRLDBDQUFFLElBQUksMENBQUUsSUFBSSwwQ0FBRSxhQUFhLENBQUE7SUFDL0QsSUFBRyxDQUFBLFlBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRSxNQUFNLEtBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQzlELE1BQU0scUJBQWEsQ0FBQyxVQUFVLENBQzdCLFNBQVMsSUFBSSxDQUFDLElBQUksK0JBQStCLENBQ2pELENBQUE7SUFDRixDQUFDO0lBRUQsSUFBSSxTQUFtQyxDQUFBO0lBRXZDLE1BQU0sR0FBRyxHQUFHLElBQUEsWUFBTSxHQUFFLENBQUE7SUFDcEIsTUFBTSxTQUFTLEdBQUcsR0FBRyxhQUFILEdBQUcsdUJBQUgsR0FBRyxDQUFFLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUE7SUFDNUUsU0FBUyxhQUFULFNBQVMs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